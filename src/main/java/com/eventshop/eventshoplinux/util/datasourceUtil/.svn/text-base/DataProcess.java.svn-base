package com.eventshop.eventshoplinux.util.datasourceUtil;

import java.awt.Point;
import java.awt.image.ColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.SampleModel;
import java.awt.image.WritableRaster;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileLock;
import java.util.Iterator;

import javax.imageio.ImageIO;
import javax.media.jai.PlanarImage;
import javax.media.jai.RasterFactory;
import javax.media.jai.TiledImage;

import org.apache.commons.logging.LogFactory;
import org.apache.commons.logging.Log;

import com.eventshop.eventshoplinux.domain.datasource.emage.Emage;
import com.eventshop.eventshoplinux.domain.datasource.emage.Message;
import com.eventshop.eventshoplinux.domain.datasource.emage.STMerger;
import com.eventshop.eventshoplinux.domain.datasource.emageiterator.EmageIterator;
import com.eventshop.eventshoplinux.util.datasourceUtil.wrapper.Wrapper;

public class DataProcess implements Runnable
{
	protected Log log=LogFactory.getLog(this.getClass().getName());

	STMerger merger;
	EmageIterator eit;
	Wrapper wrapper;
	String filepath;
	String imgpath;		// context+"results"+"dsID.jpg"

	public boolean isRunning;

	public DataProcess(STMerger merger, EmageIterator eit, Wrapper wrapper, String filepath, String imgpath)
	{
		this.merger = merger;
		this.eit = eit;
		this.wrapper = wrapper;
		this.filepath = filepath;
		this.imgpath=imgpath;
	}


	@Override
	public void run() 
	{	
		isRunning = true;

		if(wrapper != null)
			new Thread(wrapper).start();
		if(eit != null)
			new Thread(eit).start();
		if(merger != null)
			new Thread(merger).start();

//		// Start the output pipe to output the emage
		// try moving the code into each loop so that
		// the data file is overwritten each time


		int count = 0;

		// Start the process of collecting emages
		Iterator<Emage> it;
		if(merger != null) it = merger;
		else it = eit;

		while(isRunning)
		{
			while(it.hasNext())
			{
				if(!isRunning) break;

				Emage e = it.next();				

				// Formulate the emage message to be passed to operators
				Message.EmageMsg.Builder builder = Message.EmageMsg.newBuilder()
				.setTheme(e.theme)
				.setStartTime(e.startTime.getTime())
				.setEndTime(e.endTime.getTime())
				.setLatUnit(e.latUnit)
				.setLongUnit(e.longUnit)
				.setSwLat(e.swLat)
				.setSwLong(e.swLong)
				.setNeLat(e.neLat)
				.setNeLong(e.neLong)
				.setNumRows(e.numOfRows)
				.setNumCols(e.numOfColumns);

				// Get the cell values and add it to emage
				for(int i = 0; i < e.numOfRows; i++)
				{
					for(int j = 0; j < e.numOfColumns; j++)
					{
						builder.addCell(e.image[i][j]);
			
					}
			
				}

				// Build the Message
				Message.EmageMsg msg = builder.build();

				// Output the data
				byte[] data = msg.toByteArray();
				byte[] size = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(data.length).array();
				ByteArrayOutputStream result = new ByteArrayOutputStream(data.length+4);
				try {
					result.write(size);
					result.write(data);	
				} catch (IOException e1) {
					log.error(e1.getMessage());
				}

				// moved here to rewrite the output file
				// 08/19/2011 Mingyan
				FileOutputStream output = null;
				try {
					output = new FileOutputStream(filepath);
				} catch (FileNotFoundException e1) {
					log.error(e1.getMessage());
				}

				// Lock the file for writing
				FileLock lock = null;
				try {
					while(lock == null)
						lock = output.getChannel().tryLock();
					output.write(result.toByteArray());
					output.flush();			
					lock.release();

					// 08/19/2011 Mingyan
					output.close();
				} catch (IOException e1) {
					log.error(e1.getMessage());
				}

				//to create a viewable version of the datasource
				gridToEmage(e.image, imgpath+"_before" );
				double[][] overlay = createProjectedOverlay (e);
				gridToEmage(overlay, imgpath);

				count++;
				log.info("wrote " + count + " emage(s)! " + imgpath);
			} 

			try {
				Thread.sleep(5000);
			} catch (InterruptedException e) {
				log.error(e.getMessage());
			}
		}
	}


	public boolean stop()
	{
		if(wrapper != null) wrapper.stop();
		if(eit != null) eit.stop();
		if(merger != null) merger.stop();

		isRunning = false;
		Thread.currentThread().interrupt();
		return true;
	}


	public PlanarImage gridToEmage(double [][] dataGrid, String imageName)
	{
		int width = dataGrid[0].length;
		int height = dataGrid.length;

		double maxVal = -999999999;//a large NEGATIVE number which should get overwritten
		double minVal =  999999999;
		for (int i = 0; i<height; i++)
		{
			for (int j=0; j<width; j++)
			{
				if (dataGrid[i][j]>maxVal) maxVal=dataGrid[i][j];
				if (dataGrid[i][j]<minVal) minVal=dataGrid[i][j];
			}
		}
		if(minVal == -1) minVal = 0;
		
		// Get the number of bands on the image.
		int nbands = 3;
		// We assume that we can get the pixels values in a integer array.
		double[] pixel = new double[nbands];
		// Get an iterator for the image.
		WritableRaster rasterData =
			RasterFactory.createBandedRaster(DataBuffer.TYPE_BYTE,
					width,height,nbands,new Point(0,0));		

		if(maxVal > 0)
		{
			for (int i=0; i<height; i++)
			{
				for (int j=0; j<width; j++)
				{
					for (int k=0 ; k<nbands; k++)
					{
						double value = (dataGrid[i][j]-minVal)*255/(maxVal-minVal);
						if(value > 255) pixel[k] = 255;
						else pixel[k] = value;
					}
					rasterData.setPixel(j,i,pixel);
				}
			}
		}

		SampleModel sModel2 =
			RasterFactory.createBandedSampleModel(DataBuffer.TYPE_BYTE,width,height,nbands);
		// Try to create a compatible ColorModel - if the number of bands is
		// larger than 4, it will be null.
		ColorModel cModel2 = PlanarImage.createColorModel(sModel2);
		// Create a TiledImage using the sample and color models.
		TiledImage rectPollenImage = new TiledImage(0,0,width,height,0,0,sModel2,cModel2);
		// Set the data of the tiled image to be the raster.
		rectPollenImage.setData(rasterData);
		// Save the image on a file.

		try {
				ImageIO.write(rectPollenImage, "png", new File(imageName+".png"));
				FileWriter fstream = new FileWriter(imageName+".json");
				BufferedWriter out = new BufferedWriter(fstream);
				out.write("{\"minVal\":\""+minVal+"\","+ "\"maxVal\":\""+maxVal+"\"}");
				out.close();	
		} catch (IOException e) {
			log.error(e.getMessage());
			log.error("ERROr in rectifying AQI image");
		}		  
		return rectPollenImage;
	}
	

	double[][] createProjectedOverlay (Emage e)
	{

		double swLong = e.swLong;
		double neLat = e.neLat;

		double DEGREES_PER_RADIAN = 57.2957795;
		double sizeStretchRatio = 1000;
		double incomingLatUnit = e.latUnit;
		double incomingLongUnit = e.longUnit;

		double Ymax = GudermannianInv(e.neLat);
		double Ymin = GudermannianInv(e.swLat);
		int nRows = (int)Math.floor((Ymax-Ymin)*sizeStretchRatio);
		int nCols = Math.abs((int)Math.floor(sizeStretchRatio*((e.swLong-e.neLong)/DEGREES_PER_RADIAN)));

		// Get the image dimensions of the unrectified image
		int width = e.numOfColumns;
		int height = e.numOfRows;

		double [][] inMat =e.image;	
		double [][] outMat= new double[nRows][nCols];

		for (int i=0; i<nRows; i++)
		{
			for (int j=0; j<nCols; j++)
			{
				double corrLa = Gudermannian(Ymax- i/sizeStretchRatio);//
				int corrLat = (int)Math.round((neLat-corrLa)/incomingLatUnit);

			
				double curLong = swLong+j/sizeStretchRatio*DEGREES_PER_RADIAN;
				int corrLong =(int)Math.round((curLong-swLong)/incomingLongUnit);

				if ( corrLat>=0 && corrLat<height && corrLong>=0 && corrLong<width)
				{
					outMat[i][j]=inMat[corrLat][corrLong];
				}
				else
				{
					outMat[i][j]=0;
		
				}
			}
		}

		return outMat;
	}


	/// <summary>
	/// Calculates the Y-value (inverse Gudermannian function) for a latitude.

	double GudermannianInv(double latitude)
	{
		double RADIANS_PER_DEGREE=1/57.2957795;
		double sign =+1;
		if (latitude<0) sign=-1;
		double sinv = Math.sin(latitude * RADIANS_PER_DEGREE * sign);
		return sign * (Math.log((1.0 + sinv) / (1.0 - sinv)) / 2.0);
	}


	/// <summary>
	/// Returns the Latitude in degrees for a given Y.
	/// </summary>
	/// <param name="y">Y is in the range of +PI to -PI.</param>
	/// <returns>Latitude in degrees.</returns>
	double Gudermannian(double y)
	{
		double DEGREES_PER_RADIAN=57.2957795;
		return Math.atan((Math.exp(y)-Math.exp(-y))/2.0) * DEGREES_PER_RADIAN;
	}

}
